New ideas:
   What if cards edited through the interface are preserved, but cards edited
   manually are checksummed. If the checksum changes, then that card must be
   reviewed again. Hmm... That could be really interesting. Then files don't
   have to be touched... :D

DESIGN TODO:
   1.) Format of .concards directory.
   2.) All commandline parameters.
   3.) Refactor delimiters.
   4.) The specific process of extracting a card.
   5.) Concards directory having version control.

1. Format of '~/.concards/'.
Or ./config/concards/

Will all algorithms have a date. Or will they have a function instead.
If there is a function, then that computation will have to be performed on
every card for filtering. Also a function will be hard to read.

Should an @i and @o be added?
   @o would be options
   @i would be umm.. I forget
   Yeah.... nah. The data of the questions/answers will not be altered, but
   Everything else is prone to change.

Oh, when you edit a card, the id could be stored.

Are questions/answers trimmed?
   Questions/Answers can be a trimmed array of lines.

   They also need to remember if there is a line afterwards or not.

   Each card can have the original text contained within. Putting those
   together will give the original group.

   I don't need any original text for the default prettifying thing. But for
   the ignore option, each Gk

What happens if an algorithm doesn't exist.
   

If multiple algs are on the same day, then they are treated as separate cards.

If multiple questions have the same exact name, then what?
   - 1: Keep the multiple questions?
   - 2: Combine the questions with answers.
   
   I pick keep the multiple questions.

Display can keep track of extra whitespace. The parsing knows nothing about
that.

What about sub-group syntax?
   NONE

Need a binding to never review a card again.

group inference is allowed


@> @q @a @n @m

below the only anomoly is the @a.
@a goes with the last question.
@ after the start of a group though.
   Can either be ignored or treated as a question.
   Weird to treat as a question
   An answer for every single card in the group?

All possibilities:

@> @> combine groups
@> @q > then q
@> @a a for all cards in group
@> @n n for all cards in group
@> @m m for all cards in group
@> @< > then < (nothing)
      
@q @> q then g
@q @q different questions
@q @a q then a
@q @n q then n
@q @m q then m
@q @< q then <
      
@a @> a then g
@a @q a then q
@a @a multiple answers
@a @n a then n
@a @m a then m
@a @< a then <
      
@n @> n then g
@n @q n then q
@n @a q/> then a
@n @n multiple notes
@n @m n then m
@n @< n then <
      
@m @> m then g
@m @q m then q
@m @a q/> then a
@m @n m then n
@m @m multiple metas
@m @< m then <
      
These really have no/little meaning:
@< @> end then start
@< @q nothing
@< @a nothing
@< @n nothing
@< @m nothing
@< @< nothing
      
@> new-wave-questions
@q What are valid group names?
@a first thing
@a second thing

@q Are group names case sensitive?
@a Yes, because unicode can be there...

@q What about formatting for a card on the same line?
@a 
@<

Topic    <-> Comment.
Front    <-> Back.
Question <-> Answer


So below, that is an embedded flash card thing.

So now the program will parse cards out of the file. Then store the cards in
the .concards directory.

There will be an option to keep the card in a note file. But the default will
not do that. All the parsing rules could be commandline parameters. So I will
have to reform my commandline rules next.

I was thinking there is a file/directory in the user's home folder that
contains lua addons. By default, this will have the basic algorithms. Then
maybe some more. Also, the same file might exist in /etc if the user's doesn't
exist.

This would be card embedded in a lua comment. It would be nice if groups could
be declared before hand.

What if a group could be declared earlier in the file?
Ok, I really don't want a group tag.

So no parsing things metadata. yeah, no.

Okay, what if the flashcards are parsed out of the files? That actually might
not be a bad idea. Then the flashcards could be stored more efficiently in the
.concards directory

There could be only 2 parsing groups.
-- @> group1 group2 @q test @a yes @m sm2(2.70,3), 2018-10-10@14:31 @<

It would be really nice if the group could be after the @>. But then what
happens to the options?

If the parsing was just smart enough to parse correctly, then I wouldn't need
all this stuff. Or if all new lines were preceded by another @q or whatever.
No, that's a bad idea.

So smarter parsing... How would I accomplish that?
I could tell that the cards are being preceded by something common.

@> concard-s questions_are_cool
@> yes
@m sm2(2.50,0), 2018-10-10@14:31

@q Is there an alternative way to embedding a flashcard in a single line
   comment?
@a Umm, no.

@q Can a flashcard in a single line get by without being in a group?
@a This would take away from a parsing block being flexible.

@q What happens if the lua config file doesn't exist in the home directory?
@a Then the file will be created for you.

@> mommy
@q What will the config file be called/look like?
@a A lua file called "~/.concards/algs.lua". So all your configuration will go in
   this file. There is no directory.

@q Can groups be declared in the same line with commas?
@a No, because I want to be complient with unicode, there would be too much to
   think about that would be allowed/not allowed. So I will go with everything
   is allowed, up until the next @delimiter.

@q Well, what if there is a newline in the group 'name'?
   Do I just get rid of extra white space?
   Do I parse by words?
@a I get rid of the extra whitespace. So I parse by words.

@q There can be multiple answers. Answers in succession.
   But, can there be multiple questions?
   Are question/answers really the best thing to call this?
   Is front/back even applicable anymore?
   Will the UI have a front/back, or outline format?
@a No, not multiple questions. If you have another question, then you can
   either make a new card, or make it an answer.
@a Q/A and F/B are both fine to call it.

@q Can a card have multiple different fronts/backs?
@a An answer can actually have multiple parts:
@a    One:   there is a bug
@a    Two:   there is a snake
@a    Three: on the willow tree
@n If yes, then a different delimiter would have to be used for reminders.
@n If no,  then no different delimiters, and a card could have progressions.
@n A progression could be like a prerequisite.
@<




file doesn't 

@> DEF(sm2), MN(hello), DR, O, N
@> Numerical Analysis, hello, math, shuxue

@m sm2: 2018-10-10@14:31,2.70,3
@m sm2(2018-10-10@14:31,2.70,3)

@m sm2, 2018-10-10@14:31

@f Preconditioning @> ONE_LINE
@b Basically wants to multiply an equation to make the matrices look more like
   the Identity matrix. This tries to save future computation.

   Preconditioning is for GMres.

@q hello @q you need @q to go @q away

@f Jacobi Preconditioning
@b who doesn't do something like this.
   Does [Preconditioning] by using the diagonal matrix.
@n You know who. GHOST BUSTERS!
@< this specific text here means nothing at all.

Can the delim start anywhere on the line? That is a question I have asked
multiple times. If it can, then you can stack things on the same line. Then it
really comes down to the question of the meta data. Should the meta data by
default be on its own line?

And can meta data be for a group?
   If meta data can be owned by a group, then everything in that group is reviewed
   at the same time, and all the individual meta data's are ignored/deleted for
   individual cards.

Ok, delimiters can be on the same line, but the parser will overwrite this by
default. You can pass a parameter at the "@>" delimiter spot. I gotta figure
out what these delimiters look like.

All these are formatting options for what happens when the file is written.
I gotta go over these a bit probably.

Ooooh, it sorted out nicely here :).

*@> MN, META_NEWLINE  -> Put a newline before each new meta created. (Default)
_@> MO, META_ONELINE  -> Don't put a newline before newly created metas.
_@> MR, META_READONLY -> Don't touch meta data at all. (New or change).

*@> DN, DELIM_NEWLINE  -> Each thing in the card goes on a new line.
_@> DO, DELIM_ONELINE  -> Compactify each card to only be one line.
_@> DR, DELIM_READONLY -> Don't mess with the concards format at all.

*@> CN, CARDS_NEWLINE  -> Put 2 newlines in between each card. For prettiness.
_@> CO, CARDS_ONELINE  -> Put cards on on the same line.
_@> CR, CARDS_READONLY -> Don't mess with what is in between each card at all.

*@> N, NEWLINE  = META_NEWLINE  & DELIM_NEWLINE  & CARDS_NEWLINE
_@> O, ONELINE  = META_ONELINE  & DELIM_ONELINE  & CARDS_ONELINE
_@> R, READONLY = META_READONLY & DELIM_READONLY & CARDS_READONLY

Okay, let's force everything on it's own line, This means that one cannot have
whitespace before the cards. But whyshenme!!!? :(. The only way to fix this is
to not have meta data stored in the note file. If I do this, then there has to
be a way to make the meta data portable. This really can't be done though.

Can the starting/format delimiter be contained within the actual concard space?
No. Firstly not within a card, because that presents problems. Secondly just no
anywhere, because if it can't be within a card, then it doesn't even make
sense.

And make sure about my meta data thing.

-------- DEPRECATED IDEA --------
Is it really necessarry to have longer abreviations? No! Don't do it!
@>     @q      @f     @b    @n    @m
       @qmd    @frt   @bck  @not  @met
       @qemind @front @back @note @meta

Shortest SM2:
@> a @q b @m sm2(2018-10-10@14:31,2,3.10) @<

@m sm2(2018-10-10@14:31,2,3.10) 
@m fin(2018-10-10@14:31)

@m sm2()
@> @q a @<

@> a @q b @a c @n d sm2(2018-10-10@14:31,2,3.10) @<
--------       END       --------

links will go by [] (Probably... This is more of a gui thing.)

lua scripting for algorithms? That would be really cool actually. Or JS for
algorithms. (if it is in the browser).

Yeah, Lua scripting, but I'm not assuming the website. Maybe if a browser just
starts up, then that is good enough. Then that can be built off of in the
future. Even the things .... ?

So how will it look like in LUA for the creation of new algorithms? Either just
have global functions, or add the function to an array. Yeah... just global
functions is fine.

Are the default algorithms built into Go? That is another good question.

Pros: If the file is deleted, the program still works, Makes it easier for
people to use the program.

Cons: Kind of enforces a limitation

Or what if we just copy a Lua file to the correct location. No, there should be
a default location. There should be a default algorithm. I can copy the anki
algorithm.

Also, should there be a way to say, "I know this card".
Well, that could be just a "I know this" algorithm. Or just change the date to
some arbitrary time in the future. Actually, you never "know" something. You
should just move the date to 10 years from then. Nevermind, there could just be
a "known" algorithm.

I just have to assume that the "streak" and "next day to review" are not global
to every algorithm.

I will have to provide some API things for lua. Including date manipulation.
That will be important. Yeah, the Lua needs to have the current date. Dates are
just strings.

So the lua API includes string and math modules plus this date one:
```lua
-- if any of these have an error, then null is returned.
-- a "date" is just a string with a date and a time.
-- Returns the current date (a table)
function date.today() end

-- if anything is larger than what it should be, then that adds to the date.
-- takes in a table:
-- { year=2018, month=6, day=16, hour=6, min=41 }
-- nil values are ignored.
function date.stringify(date) end

-- returns the date, but makes sure all the values are valid. if nils are
-- found, then those become the base value. (a nil year would be the lowest
-- year (19something).
function date.balance(date) end

-- this returns all values as a table
-- { year=2018, month=6, day=16, hour=6, min=41 }
function date.parse(str) end

```

And a function would look like this:

function sm2(params, card)

end

There should
